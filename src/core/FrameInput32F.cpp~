#include "FrameInput32F.h"

FrameInput32F::FrameInput32F(){}
FrameInput32F::FrameInput32F(Calibration * cal, string rgbpath, string depthpath){
	calibration = cal;

	width = 640;
	height = 480;

	rgb_path		= rgbpath;
	depth_path		= depthpath;
	depth_in_ram	= false;
	rgb_in_ram		= false;
	load_rgb();
	load_depth();

	cvNamedWindow("input rgb", CV_WINDOW_AUTOSIZE );
	IplImage * img = get_rgb_img();
	printf("img 32 bit img:%ld\n",(unsigned long)img);
	cvShowImage("input rgb", img);
	cvWaitKey(0);
}

FrameInput32F::~FrameInput32F(){}

float *** FrameInput::full_getXYZ(int & w, int & h){
	load_depth();

	float d_scaleing	= calibration->ds/calibration->scale;
	float centerX		= calibration->cx;
	float centerY		= calibration->cy;
	float invFocalX		= 1.0f/calibration->fx;
    float invFocalY		= 1.0f/calibration->fy;
	float * depth_data	= (float *)depth_img->imageData;
	w = width;
	h = height;
	float *** mat = new float**[3];
	mat[0] = new float*[width];
	mat[1] = new float*[width];
	mat[2] = new float*[width];
	
	for(int w = 0; w < width; w++){
		mat[0][w] = new float[height];
		mat[1][w] = new float[height];
		mat[2][w] = new float[height];

		for(int h = 0; h < height; h++){
			int ind = width*h+w;
			float tmp_z = float(depth_data[ind]) * d_scaleing;
			float tmp_x = 0;
			float tmp_y = 0;

			if(tmp_z > 0){
				tmp_x = (w - centerX) * tmp_z * invFocalX;
		       	tmp_y = (h - centerY) * tmp_z * invFocalY;
			}else{tmp_x = tmp_y = tmp_z = NAN;}

			mat[0][w][h] = tmp_x;
			mat[1][w][h] = tmp_y;
			mat[2][w][h] = tmp_z;
		}
	}
	depth_last_use_timestamp		= current_time();
	return mat;
}

void FrameInput::getXYZ(float & x, float & y, float & z,int w, int h){
//	load_depth();
/*
	float d_scaleing	= calibration->ds/calibration->scale;
	float centerX		= calibration->cx;
	float centerY		= calibration->cy;
	float invFocalX		= 1.0f/calibration->fx;
    float invFocalY		= 1.0f/calibration->fy;
	float * depth_data_f = (float *)depth_img->imageData;
	int * depth_data_i	 = (int *)depth_img->imageData;

	cv::Mat m(depth_img);
	int ind = width*h+w;

	int ddi = depth_data_i[ind];
	float ddf = depth_data_f[ind];
	float dds = m.at<float>(w,h);
	printf("ddi: %i ddf: %f dds: %f \n",ddi,ddf,dds);
*/
	cv::Mat m = cv::imread(depth_path.c_str(),-1);
	float dds1 = m.at<float>(w,h);
	int dds2 = m.at<int16_t>(w,h);
	printf("%i %i -> %.15f -> %i\n",w,h,dds1,dds2);
/*
	float tmp_z = float(depth_data_f[ind]) * d_scaleing;
	
	float tmp_x = 0;
	float tmp_y = 0;

	if(tmp_z > 0){
		tmp_x = (w - centerX) * tmp_z * invFocalX;
       	tmp_y = (h - centerY) * tmp_z * invFocalY;
	}else{	tmp_x = NAN;
			tmp_y = NAN;
			tmp_z = NAN;}
	x = tmp_x;
	y = tmp_y;
	z = tmp_z;
	//if(depth_data[ind] != 0){printf("w h d = %i %i %f x y z = %f %f %f\n",w,h,depth_data[ind],x,y,z);}
*/
	depth_last_use_timestamp		= current_time();
}
void FrameInput::vector_getXYZ(vector<float> & x, vector<float> & y, vector<float> & z, vector<int> & w_vec, vector<int> & h_vec){
	load_depth();

	x.resize(w_vec.size());
	y.resize(w_vec.size());
	z.resize(w_vec.size());

	float d_scaleing	= calibration->ds/calibration->scale;
	float centerX		= calibration->cx;
	float centerY		= calibration->cy;
	float invFocalX		= 1.0f/calibration->fx;
    float invFocalY		= 1.0f/calibration->fy;
	float * depth_data	= (float *)depth_img->imageData;

	for(unsigned int i = 0; i < w_vec.size(); i++){
		int w = w_vec.at(i);
		int h = h_vec.at(i);
		int ind = h*width + w;
		float tmp_x = 0;
		float tmp_y = 0;
		float tmp_z = float(depth_data[ind]) * d_scaleing;
		
		if(tmp_z > 0){
			tmp_x = (w - centerX) * tmp_z * invFocalX;
		   	tmp_y = (h - centerY) * tmp_z * invFocalY;
		}else{tmp_x = tmp_y = tmp_z = NAN;}
		x.push_back(tmp_x);
		y.push_back(tmp_y);
		y.push_back(tmp_z);
	}

	depth_last_use_timestamp		= current_time();
}

pcl::PointCloud<pcl::PointXYZRGB> FrameInput::getCloud(){
	load_rgb();
	load_depth();
	pcl::PointCloud<pcl::PointXYZRGB> cloud;
	cloud.width    = width;
	cloud.height   = height;
	cloud.is_dense = false;
	cloud.points.resize (cloud.width * cloud.height);

	float d_scaleing	= calibration->ds/calibration->scale;
	float centerX		= calibration->cx;
	float centerY		= calibration->cy;
	float invFocalX		= 1.0f/calibration->fx;
    float invFocalY		= 1.0f/calibration->fy;
	float * depth_data	= (float *)depth_img->imageData;
	char * rgb_data				= (char *)(rgb_img->imageData);

	for(int w = 0; w < width; w++){
		for(int h = 0; h < height; h++){
			int ind = h*width + w;

			int tmp_r = char(rgb_data[3*ind+2]);
			int tmp_g = char(rgb_data[3*ind+1]);
			int tmp_b = char(rgb_data[3*ind+0]);

			if(tmp_r < 0){tmp_r = 255+tmp_r;}
			if(tmp_g < 0){tmp_g = 255+tmp_g;}
			if(tmp_b < 0){tmp_b = 255+tmp_b;}

			float tmp_x = 0;
			float tmp_y = 0;
			float tmp_z = float(depth_data[ind]) * d_scaleing;
		
			if(tmp_z > 0){
				tmp_x = (w - centerX) * tmp_z * invFocalX;
			   	tmp_y = (h - centerY) * tmp_z * invFocalY;
			}
			cloud.points[ind].x = tmp_x;
			cloud.points[ind].y = tmp_y;
			cloud.points[ind].z = tmp_z;
			cloud.points[ind].r = tmp_r;
			cloud.points[ind].g = tmp_g;
			cloud.points[ind].b = tmp_b;
		}
	}
	rgb_last_use_timestamp = rgb_last_use_timestamp = current_time();
	return cloud;
}

